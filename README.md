Задача 1. Написать функцию, разворачивающую строку, считанную с клавиатуры. задом наперёд 
Пример: 
Enter your string: abc 
Reversed: cba
Пояснение:
Я использовал 32-битную систему Linux (x86, IA-32), https://syscalls.mebeim.net/?table=x86/64/ia32/latest
section .bss – секция для хранения неинициализированных данных, в ней мы резервируем память с помощью resb – псевдо-инструкции (говорит выделить указанное количества байт, начиная с адреса buffer,  но не инициализировать их), в итоге строка для резервирования 100 байт будет выглядеть следующим образом: buffer resb 100.
section .data – секция для инициализированных данных. Нам нужно инициализировать строку "Enter your string: ". Так как каждый символ строки хранит числовой код (от 0 до 255), то можем использовать директиву db. Далее с помощью директивы equ создадим константу length_in, которая будет равна количеству байтов в строке input. Те же самые действия проделываем со строкой «Reversed».
section .text – секция кода, в которой лежат команды, которые будет исполнять процессор. _start – точка входа в программу.
Выводим "Enter your string: ". Записываем в регистр eax номер системного вызова 4 (sys_write), в ebx помещаем файловый дескриптор 1 – вывод (0 – ввод, 2 – вывод ошибок). В свободные регистры записываем input (нашу строку) и length_in (= количество байтов input). Выполняем системный вызов sys_write с помощью инструкции int 0x80.
Считывание строку с клавиатуры. Записываем в регистр eax номер системного вызова 3 (sys_read), в ebx помещаем файловый дескриптор 0 – ввод. В регистр ecx записываем адрес буфера buffer и в edx максимальное число байтов. Выполняем системный вызов sys_read с помощью инструкции int 0x80.
Записываем в незанятый регистр (esi) длину считанной строки и указываем на последний символ введенного слова (последний введенный символ появляется из-за enter).
Выводим "Reversed: ". Записываем в регистр eax номер системного вызова 4 (sys_write), в ebx помещаем файловый дескриптор 1 – вывод. В регистр ecx помещаем помещаем адрес output и в регистре edx указываем ее длину length_out. Выполняем системный вызов sys_read с помощью инструкции int 0x80.
print_loop: - начало цикла. Берем один байт из памяти по адресу buffer + esi и кладем его в al (мы работаем с одним символом – значит с одним байтом). Дальше копируем в память адресу buffer + esi + 1. Записываем в регистр eax номер системного вызова 4 (sys_write), в ebx помещаем файловый дескриптор 1 – вывод. Далее кладем в регистр ECX адрес символа buffer + esi. В edx записываем число байт, которое хотим вывести. Выполняем int 0x80. 
Сравниваем esi c нулем (если = , то все символы уже написали).Если не равно, то в начало цикла (jne print_loop).
Делаем перевод строки. Завершаем программу системным вызовом sys_exit.
